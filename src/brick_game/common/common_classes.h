#ifndef COMMON_CLASSES_H
#define COMMON_CLASSES_H

#include <stdlib.h>
#include <time.h>

#include "common_matrix.h"

/**
 * @file
 * @brief объявления общих структур для игр
 *
 * @details структуры являются общими для всех игр в соответствии со
 * спецификацией из materials/library-specification.md. Это необходимо для
 * реализации общего пользовательского интерфейса
 */

/// @brief информация о движущейся фигуре
typedef struct {
  int **figure;  ///< указатель на массив, хранящий падающую фигуру / яблоко
  int idx;  ///< порядковый номер падающей фигуры (1-7) в соответствии с
            ///< SRS-pieces.png. idx = 4 для яблока
  int row;  ///< номер ряда верхнего левого угла сектора фигуры относительно
            ///< поля
  int col;  ///< номер столбца верхнего левого угла сектора фигуры относительно
            ///< поля
  int rows;  ///< количество рядов в массиве, хранящем падающую фигуру. Для
             ///< фигур 2-3 и 5-7 значение равно 3, для фигуры 1 значение равно
             ///< 4, для фигуры 4 значение равно 2. Для яблока значение равно 1
  int columns;  ///< количество рядов в массиве, хранящем падающую фигуру.
                ///< Аналогично полю rows
} moving_t;

/**
 * @brief информация об игре
 *
 */
typedef struct {
  int **field;  ///< указатель на массив, хранящий размещение фигур/змейки на
                ///< игровом поле
  int **field_copy;  ///< копия игрового поля. Информация о поражении и паузе
                     ///< выводится прямо на поле, поэтому состояние поля нужно
                     ///< где-то сохранить
  moving_t *moving;  ///< указатель на структуру, храняющую информацию о
                     ///< падающей фигуре. Для змейки хранится позиция яблока
  int **next;  ///< массив, хранящий очередную фигуру. NULL в змейке
  int next_idx;  ///< порядковый номер очередной фигуры (1-7) в соответствии с
                 ///< SRS-pieces.png. 0 для змейки
  int score;     ///< счет игрока в текущей игре
  int high_score;  ///< рекорд игрока
  int level;  ///< уровень игры от 1 до 10. Чем выше уровень - тем выше скорость
              ///< игры
  int delay;  ///< время, отведенное для принятия решения пользователем в
              ///< MOVING_STATE
  char *user_name;  ///< имя пользователя, полученное при авторизации
  char *bottom_text;  ///< поле для хранения приветственного текста и
                      ///< инструкций, которые выводятся в режиме паузы, в
                      ///< начале и в конце игры
  bool pause;  ///< флаг состояния паузы. При true необходимо приостановить
               ///< счетчик и вывести экран паузы
  bool game_over;  ///< флаг проигрыша
  bool game_won;   ///< флаг выигрыша
  struct timespec *tick_end_time;  ///< указатель на структуру, хранящую время
                                   ///< конца такта MOVING_STATE. Поле
                                   ///< необходимо для реализации таймера КА
  int game_id;  ///< идентификатор игры. 0 - для тетриса, 1 - для змейки
} GameInfo_t;

/// @brief действия пользователя
typedef enum {
  START,
  PAUSE,
  TERMINATE,
  LEFT,
  RIGHT,
  UP,
  DOWN,
  ACTION,
  NO_ACTION
} UserAction_t;

class Controller {
 public:
  virtual void userInput(UserAction_t action) noexcept = 0;
  virtual ~Controller() {}
};

/// @brief синглтон, хранящий static-переменную типа GameInfo
/// @param game_info для инициализации static-переменной передается валидный
/// указатель GameInfo_t. Для получения текущего состояния передается NULL
/// @return указатель на память, хранящую текущее состояние игры
GameInfo_t *current_game_info(GameInfo_t *game_info);

/// @brief функция для получения данных для отрисовки в интерфейсе
/// @return копия текущего состояния игры. Именно копия, так как интерфейс не
/// должен иметь возможности вносить изменения в структуру, а только читать её
GameInfo_t updateCurrentState();

/// @brief очиста памяти, выделенной под структуру, хранящую информацию о
/// падающей фигуре / яблоке
/// @param moving_info структура для очистки памяти
void destroy_moving(moving_t *moving_info);

/// @brief очистка памяти, выделенной под структуру GameInfo_t
void destroy_game_info();

#endif