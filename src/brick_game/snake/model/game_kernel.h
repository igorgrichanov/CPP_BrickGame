#ifndef GAME_KERNEL_H
#define GAME_KERNEL_H

#include <iostream>
#include <vector>

#include "../../common/common_classes.h"
#include "../../common/common_functions.h"
#include "../../common/common_matrix.h"
#include "defines.h"
#include "snake.h"

/**
 * @file
 * @brief ядро игры "Змейка", выполняющее проверки, вычисления, а также
 * подготовку структуры GameInfo_t к отправке на UI
 */

/**
 * @mainpage Реализация игры "Змейка" на языке C++
 * Данный проект представляет реализацию игры "Змейка". Логика игры реализована
 * с использованием конечного автомата.
 *
 * Проект состоит из двух отдельных компонентов:
 * библиотеки, отвечающей за реализацию логики игры, и десктопного графического
 * интерфейса
 *
 * @image html snake_desktop_screen.png
 *
 * Игрок управляет змейкой, которая непрерывно движется вперед. Игрок изменяет
 * направление движения змейки с помощью стрелок. Цель игры заключается в сборе
 * «яблок» появляющихся на игровом поле. При этом игрок не должен касаться
 * стенок игрового поля. После «поедания» очередного «яблока» длина змейки
 * увеличивается на один. Игрок побеждает, если змейка достигает максимального
 * размера (200 «пикселей»). Если змейка сталкивается с границей игрового поля,
 * то игрок проигрывает.
 *
 * @section Architecture Игра реализована с использованием паттерна MVC
 * @image html MVC-Process.png
 * Паттерн MVC (Model-View-Controller, Модель-Представление-Контроллер)
 * представляет из себя схему разделения модулей приложения на три отдельных
 * макрокомпонента: модель, содержащую в себе бизнес-логику, представление —
 * форму пользовательского интерфейса для осуществления взаимодействия с
 * программой и контроллер, осуществляющий модификацию модели по действию
 * пользователя.
 *
 * @section FSM Конечный автомат игры "Змейка" выглядит следующим образом
 * @image html fsm_snake.png
 * @section Данный КА состоит из следующих состояний:
 *
 *    - START_STATE — состояние, в котором игра ждет, пока игрок нажмет кнопку
 * готовности к игре или выхода из игры;
 *    - SPAWN_STATE — состояние, в которое переходит игра после поедания змейкой
 * яблока;
 *    - MOVING_STATE — основное игровое состояние с обработкой ввода от
 * пользователя — поворота змейки, ускорения движения, паузы и окончания игры;
 *    - SHIFTING_STATE — состояние, в которое переходит игра после истечения;
 * таймера. В нем змейка перемещается вперед на одну клетку. Здесь же происходят
 * проверки на то, было ли съедено яблоко и не столкнулась ли змейка либо сама с
 * собой, либо со стенкой;
 *    - PAUSE_STATE - состояние паузы, при котором игра замирает до отмены
 * пользователем;
 *    - END_STATE - состояние, в которое переходит игры после столкновения
 * змейки с самой собой или со стенкой;
 *    - EXIT_STATE - состояние, в которое переходит игра, если пользователь
 * решил выйти из программы. В нем происходит освобождение ресурсов.
 *
 * Десктопный интерфейс полностью поддерживает игру, разработанную в проекте
 * BrickGame v1.0. Консольный интерфейс, разработанный в BrickGame v1.0,
 * полностью поддерживает "Змейку".
 *
 * @image html snake_cli_screen.png
 *
 * @section Тетрис Проект BrickGame v1.0 – тетрис
 *
 * Цель игры тетрис, разработанной в проекте BrickGame v1.0, заключается в
 * наборе очков за построение линий из генерируемых игрой блоков. Очередной
 * блок, сгенерированный игрой, начинает опускаться вниз по игровому полю, пока
 * не достигнет нижней границы или не столкнется с другим блоком. Пользовать
 * может поворачивать фигуры и перемещать их по горизонтали, стараясь составлять
 * ряды. После заполнения ряд уничтожается, игрок получает очки, а блоки,
 * находящиеся выше заполненного ряда опускаются вниз. Игра заканчивается, когда
 * очередная фигура останавливается в самом верхнем ряду.
 * @image html tetr.png
 *
 * @section Tetraminos В игре используется 7 видов фигур
 * @image html SRS-pieces.png
 * Фигуры выбрасываются в случайном порядке.
 *
 * @section FSM Конечный автомат игры "Тетрис" выглядит следующим образом
 * @image html fsm_tetris.png
 * @section Данный КА состоит из следующих состояний:
 *
 *    - START_STATE — состояние, в котором игра ждет, пока игрок нажмет кнопку
 * готовности к игре.
 *    - SPAWN_STATE — состояние, в которое переходит игра при создании
 * очередного блока и выбора следующего блока для спавна.
 *    - MOVING_STATE — основное игровое состояние с обработкой ввода от
 * пользователя — поворот блоков/перемещение блоков по горизонтали.
 *    - SHIFTING_STATE — состояние, в которое переходит игра после истечения
 * таймера. В нем текущий блок перемещается вниз на один уровень.
 *    - PAUSE_STATE - состояние паузы, при котором игра замирает до отмены
 * пользователем
 *    - ATTACHING_STATE - состояние, в которое преходит игра после
 * «соприкосновения» текущего блока с уже упавшими или с землей. Если образуются
 * заполненные линии, то она уничтожается и остальные блоки смещаются вниз. Если
 * блок остановился в самом верхнем ряду, то игра переходит в состояние «игра
 * окончена».
 *    - GAME_OVER_STATE - состояние, в котором сохраняется рекорд, если он был
 * побит
 *    - EXIT_STATE - состояние, в которое переходит игра, если пользователь
 * решил выйти из программы. В нем происходит освобождение ресурсов
 *
 * Программа состоит из двух частей: библиотеки,
 * реализующей логику игры "Тетрис", и терминального интерфейса, реализованного
 * с помощью библиотеки ncurses.
 */

namespace brickGame {
class GameKernel final {
 public:
  GameKernel(char *user_name);
  ~GameKernel();

  /** @brief изменить направление движения змейки
   *
   * @details направление изменится в случае, если оно меняется на 90
   * градусов. Иначе никаких изменений не произойдет
   *
   * @param direction новое направление движения
   *
   * @return true направление движения змейки изменилось
   * @return false направление движения змейки не изменилось
   */
  bool change_direction(UserAction_t direction) noexcept;

  /**
   * @brief движение змейки вперед относительно текущего направления
   *
   * @return true яблоко съедено, змейка увеличилась на 1
   * @return false яблоко не съедено
   */
  bool shift_forward() noexcept;

  /**
   * @brief проверка, не наступило ли хотя бы одно условие окончания игры
   *
   * @return true наступило условие окончания игры
   * @return false не наступило условие окончания игры
   */
  bool check_game_over() noexcept;

  /**
   * @brief обновить структуру с информацией об игре, предназначенную для
   * вывода актуальной версии игры на экран
   *
   */
  void update_game_info() noexcept;

  /**
   * @brief сбросить игру к начальному состоянию
   *
   */
  void prepare_new_game() noexcept;

  /**
   * @brief получение текущего счета игрока
   *
   * @return int счет игрока в игре
   */
  int get_score() noexcept;

  /**
   * @brief обновление рекорда в базе, если он был побит
   *
   */
  void update_record() noexcept;

  /**
   * @brief добавление очка в случае, если яблоко съедено
   *
   */
  void add_point() noexcept;

  /**
   * @brief спавн нового яблока в свободной ячейке игрового поля
   *
   * @exception отсутствие свободных ячеек
   */
  void generate_apple();

  /**
   * @brief удалить текст, выводимый под рамкой с игрой в консоли и освободить
   * память, выделенную под него
   *
   */
  void free_bottom_text() noexcept;

  /**
   * @brief подготовить GameInfo_t к переходу на состояние паузы
   *
   */
  void prepare_for_pause() noexcept;

  /**
   * @brief восстановить GameInfo_t после выхода из паузы
   *
   */
  void recover_after_pause() noexcept;

  /**
   * @brief подготовить GameInfo_t к выходу из игры
   *
   */
  void prepare_exit_state() noexcept;

 private:
  Snake *snake_;
  Segment apple_;
  GameInfo_t *info_;

  /**
   * @brief инициализация структуры, содержащей информацию об игре
   *
   * @param user_name имя пользователя, введенное при авторизации
   * @return GameInfo_t* структура с данными об игре и игроке
   */
  GameInfo_t *init_game_info_snake(char *user_name) noexcept;

  /**
   * @brief инициализация структуры, хранящей информацию о положении змейки на
   * поле
   *
   */
  moving_t *init_moving_snake() noexcept;

  /**
   * @brief инициализация генератора рандомных чисел
   *
   */
  void set_random_seed() noexcept;

  /**
   * @brief заполнение игрового поля
   *
   */
  void fill_field() noexcept;

  /**
   * @brief актуализация уровня игры
   *
   */
  void change_level() noexcept;
};
}  // namespace brickGame

#endif